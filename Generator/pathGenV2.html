<!DOCTYPE html>
<html>
<head>
    <title>FTC OdoEngine Path Generator</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; background: #1a1a1b; color: white; margin: 20px; }
        canvas {
            background-color: #2d2d2e;
            background-image: url('field.png');
            background-position: center;
            background-size: cover;
            border: 4px solid #3d3d3e;
            cursor: crosshair;
            border-radius: 4px;
        }
        .controls { margin: 20px; padding: 20px; background: #2d2d2e; border-radius: 12px; width: 900px; }
        textarea { width: 100%; height: 200px; font-family: 'Consolas', monospace; margin-top: 10px; border: 1px solid #444; background: #1a1a1b; color: #10b981; padding: 10px; border-radius: 4px; }
        .toolbar { display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
        button { padding: 10px 20px; font-weight: bold; cursor: pointer; border: none; border-radius: 6px; }
        .btn-clear { background: #ef4444; color: white; }
        .btn-copy { background: #4f46e5; color: white; }
        .btn-delete { background: #f97316; color: white; }
        .btn-undo { background: #8b5cf6; color: white; }
        .segment-controls { display: flex; gap: 8px; align-items: center; background: #1a1a1b; padding: 8px 12px; border-radius: 6px; border: 1px solid #444; flex-wrap: wrap; }
        .segment-controls label { font-size: 12px; color: #cbd5e1; }
        .segment-controls select, .segment-controls input { padding: 6px; border-radius: 4px; border: 1px solid #444; background: #0f172a; color: #fff; font-size: 12px; }
        .legend { margin-top: 12px; font-size: 12px; color: #94a3b8; }
        .legend span { margin-right: 20px; }
        .mode-selector { display: flex; gap: 8px; margin-bottom: 10px; }
        .mode-btn { padding: 10px 15px; background: #4f46e5; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; }
        .mode-btn.active { background: #10b981; }
        .decoder-section { display: none; background: #1a1a1b; padding: 12px; border-radius: 6px; border: 1px solid #444; margin-bottom: 10px; }
        .decoder-section.show { display: block; }
        .decoder-input { width: 100%; padding: 8px; margin: 8px 0; border: 1px solid #444; background: #0f172a; color: #fff; border-radius: 4px; font-family: monospace; }
    </style>
</head>
<body>
    <h2>PID Engine Path Generator</h2>
    
    <div class="mode-selector">
        <button class="mode-btn active" onclick="setMode('robot')">ðŸ¤– Robot-Oriented</button>
        <button class="mode-btn" onclick="setMode('field')">ðŸŽ¯ Field-Oriented</button>
        <button class="mode-btn" onclick="toggleDecoder()">ðŸ”“ Decode Auto</button>
    </div>

    <canvas id="field" width="600" height="600"></canvas>

    <div class="decoder-section" id="decoderSection">
        <label>Paste Auto Code Here:</label>
        <textarea id="decoderInput" class="decoder-input" placeholder="Paste generated code or Java path..."></textarea>
        <button onclick="decodeAndVisualize()">Decode Path</button>
    </div>

    <div class="controls">
        <div class="toolbar">
            <button class="btn-clear" onclick="clearPath()">Clear Path</button>
            <button class="btn-undo" onclick="undo()">â†¶ Undo</button>
            <button class="btn-delete" onclick="deleteSelectedPoint()">Delete Point</button>
            <button onclick="toggleSetStart()">Set Start</button>
            <button onclick="toggleAddAction()">Add Action</button>
            <button onclick="simulate()">Simulate</button>
            <button class="btn-copy" onclick="copyCode()">Copy Code</button>
        </div>
        <div class="segment-controls">
            <label id="segmentLabel">Selected Segment Type:</label>
            <select id="segmentType">
                <option value="drive">Drive (Blue)</option>
                <option value="strafe">Strafe (Yellow)</option>
                <option value="arc">Arc (Cyan)</option>
            </select>
            <label style="margin-left: 16px;" id="arcSpeedLabel">Arc Speed:</label>
            <input id="arcSpeed" type="number" value="0.8" step="0.1" min="0.1" max="2.0" style="width: 60px;">
            <label style="margin-left: 16px;">Sim Speed:</label>
            <input id="simSpeed" type="range" value="1" step="0.1" min="0.1" max="3" style="width: 100px;">
            <span id="simSpeedLabel" style="font-size: 12px; color: #cbd5e1; min-width: 30px;">1.0x</span>
        </div>
        <div class="legend">
            <span style="color: #3b82f6;">â–ˆ Blue: drivePID</span>
            <span style="color: #eab308;">â–ˆ Yellow: strafePID</span>
            <span style="color: #06b6d4;">â–ˆ Cyan: arc()</span>
        </div>
        <textarea id="output" readonly></textarea>
    </div>

    <script>
        const canvas = document.getElementById('field');
        const ctx = canvas.getContext('2d');
        const output = document.getElementById('output');
        const fieldMeters = 3.6576; // FTC field dimension in meters
        let ppm = canvas.width / fieldMeters;
        let drawX = 0, drawY = 0, drawW = canvas.width, drawH = canvas.height;

        // Mode state
        let currentMode = 'robot'; // 'robot' or 'field'
        let history = [];

        // helpers
        function radToDeg(r) { return r * 180 / Math.PI; }
        function degToRad(d) { return d * Math.PI / 180; }
        function wrapDeg(d) { while (d > 180) d -= 360; while (d < -180) d += 360; return d; }

        // load field image
        const fieldImg = new Image();
        fieldImg.src = 'field.png';
        fieldImg.onload = () => {
            const scale = Math.min(canvas.width / fieldImg.width, canvas.height / fieldImg.height);
            drawW = fieldImg.width * scale;
            drawH = fieldImg.height * scale;
            drawX = (canvas.width - drawW) / 2;
            drawY = (canvas.height - drawH) / 2;
            ppm = drawW / fieldMeters;
            draw();
        };

        let waypoints = [];
        let markers = [];
        let nextMarkerId = 1;
        let start = { x: 0, y: 0, h: 0 };
        let draggingIdx = -1;
        let draggingHIdx = -1;
        let draggingArcControlIdx = -1;
        let setStartMode = false;
        let addActionMode = false;
        let isSimulating = false;
        let selectedSegmentIdx = null;
        let simSpeed = 1.0;

        function saveState() {
            history.push({
                waypoints: JSON.parse(JSON.stringify(waypoints)),
                markers: JSON.parse(JSON.stringify(markers)),
                start: JSON.parse(JSON.stringify(start)),
                selectedSegmentIdx: selectedSegmentIdx
            });
            if (history.length > 20) history.shift();
        }

        function undo() {
            if (history.length === 0) return;
            const state = history.pop();
            waypoints = state.waypoints;
            markers = state.markers;
            start = state.start;
            selectedSegmentIdx = state.selectedSegmentIdx;
            draw();
            generateCode();
        }

        function setMode(mode) {
            currentMode = mode;
            const btns = document.querySelectorAll('.mode-btn');
            btns.forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update segment controls visibility
            const segmentLabel = document.getElementById('segmentLabel');
            const arcSpeedLabel = document.getElementById('arcSpeedLabel');
            const segmentSelect = document.getElementById('segmentType');
            const arcSpeedInput = document.getElementById('arcSpeed');
            
            if (mode === 'field') {
                segmentLabel.style.display = 'none';
                segmentSelect.style.display = 'none';
                arcSpeedLabel.style.display = 'none';
                arcSpeedInput.style.display = 'none';
            } else {
                segmentLabel.style.display = 'inline';
                segmentSelect.style.display = 'inline';
                arcSpeedLabel.style.display = 'inline';
                arcSpeedInput.style.display = 'inline';
            }
            
            draw();
            generateCode();
        }

        function toggleDecoder() {
            const section = document.getElementById('decoderSection');
            section.classList.toggle('show');
        }

        function decodeAndVisualize() {
            const code = document.getElementById('decoderInput').value;
            if (!code.trim()) return;

            try {
                // Parse Pose2d coordinates from the code
                const poseRegex = /new\s+Pose2d\((-?\d+\.?\d*),\s*(-?\d+\.?\d*),.*?(?:Rotation2d\.fromDegrees\((-?\d+\.?\d*)\)|new\s+Rotation2d\((-?\d+\.?\d*)\))\)/g;
                
                saveState();
                waypoints = [];
                markers = [];
                
                let match;
                let idx = 0;
                while ((match = poseRegex.exec(code)) !== null) {
                    const x = parseFloat(match[1]) / 100; // Convert CM to meters
                    const y = parseFloat(match[2]) / 100;
                    const angle = parseFloat(match[3] || match[4] || 0);
                    
                    if (idx === 0) {
                        start = { x, y, h: degToRad(-angle) };
                    } else {
                        waypoints.push({
                            x, y,
                            h: degToRad(-angle),
                            segmentType: 'drive',
                            arcSpeed: 0.8
                        });
                    }
                    idx++;
                }
                
                if (waypoints.length > 0) {
                    selectedSegmentIdx = 0;
                    document.getElementById('decoderSection').classList.remove('show');
                    draw();
                    generateCode();
                }
            } catch (e) {
                alert('Failed to decode: ' + e.message);
            }
        }

        function toPixels(mx, my) {
            return {
                x: drawX + (mx + fieldMeters/2) * ppm,
                y: drawY + drawH - (my + fieldMeters/2) * ppm
            };
        }

        function toMeters(px, py) {
            return {
                x: ((px - drawX) / ppm) - (fieldMeters / 2),
                y: ((drawY + drawH - py) / ppm) - (fieldMeters / 2)
            };
        }

        const btnAddAction = document.querySelector('button[onclick="toggleAddAction()"]');
        const segmentTypeSelect = document.getElementById('segmentType');
        const arcSpeedInput = document.getElementById('arcSpeed');
        const simSpeedInput = document.getElementById('simSpeed');
        const simSpeedLabel = document.getElementById('simSpeedLabel');
        
        simSpeedInput.addEventListener('change', () => {
            simSpeed = parseFloat(simSpeedInput.value);
            simSpeedLabel.textContent = simSpeed.toFixed(1) + 'x';
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;
            const m = toMeters(px, py);

            // test hit on start
            const startPos = toPixels(start.x, start.y);
            const ds = Math.hypot(px - startPos.x, py - startPos.y);
            if (ds < 10) { draggingIdx = -2; return; }

            // test hit on waypoint circles
            for (let i = 0; i < waypoints.length; i++) {
                const pos = toPixels(waypoints[i].x, waypoints[i].y);
                if (Math.hypot(px - pos.x, py - pos.y) < 10) {
                    selectedSegmentIdx = i;
                    if (waypoints[i].segmentType) segmentTypeSelect.value = waypoints[i].segmentType;
                    if (waypoints[i].arcSpeed) arcSpeedInput.value = waypoints[i].arcSpeed;
                    draggingIdx = i;
                    return;
                }
                // Arc control point hit
                if (waypoints[i].segmentType === 'arc' && waypoints[i].arcControlPoint) {
                    const acp = toPixels(waypoints[i].arcControlPoint.x, waypoints[i].arcControlPoint.y);
                    if (Math.hypot(px - acp.x, py - acp.y) < 10) {
                        draggingArcControlIdx = i;
                        return;
                    }
                }
                // rotation handle hit
                const hpos = handlePosPixels(waypoints[i]);
                if (Math.hypot(px - hpos.x, py - hpos.y) < 10) { draggingHIdx = i; return; }
            }

            // test start rotation handle
            const sh = startHandlePosPixels();
            if (Math.hypot(px - sh.x, py - sh.y) < 10) { draggingHIdx = -2; return; }

            if (setStartMode) {
                saveState();
                start = { x: m.x, y: m.y, h: 0 };
                setStartMode = false;
                draw(); generateCode();
                return;
            }

            // If clicked on an existing marker, append it as an action node
            for (let i = 0; i < markers.length; i++) {
                const mp = toPixels(markers[i].x, markers[i].y);
                if (Math.hypot(px - mp.x, py - mp.y) < 10) {
                    saveState();
                    let insertAt = waypoints.length;
                    for (let j = waypoints.length - 1; j >= 0; j--) {
                        if (!waypoints[j].isAction) { insertAt = j + 1; break; }
                    }
                    waypoints.splice(insertAt, 0, { x: markers[i].x, y: markers[i].y, h: 0, isAction: true, actionId: markers[i].id });
                    draw(); generateCode();
                    return;
                }
            }

            if (addActionMode) {
                const name = prompt('Action name (function in AutoEngine):', 'customAction');
                if (name === null || name.trim() === '') { addActionMode = false; draw(); return; }
                const args = prompt('Arguments (comma separated, optional):', '');

                saveState();
                let found = null;
                for (let i = 0; i < markers.length; i++) {
                    const d = Math.hypot(markers[i].x - m.x, markers[i].y - m.y);
                    if (d < (5 / ppm) && markers[i].name === name.trim()) { found = markers[i]; break; }
                }

                if (found) {
                    let insertAt = waypoints.length;
                    for (let j = waypoints.length - 1; j >= 0; j--) {
                        if (!waypoints[j].isAction) { insertAt = j + 1; break; }
                    }
                    waypoints.splice(insertAt, 0, { x: found.x, y: found.y, h: 0, isAction: true, actionId: found.id });
                } else {
                    const id = nextMarkerId++;
                    const marker = { id: id, x: m.x, y: m.y, name: name.trim(), args: args ? args.trim() : '' };
                    markers.push(marker);
                    let insertAt = waypoints.length;
                    for (let j = waypoints.length - 1; j >= 0; j--) {
                        if (!waypoints[j].isAction) { insertAt = j + 1; break; }
                    }
                    waypoints.splice(insertAt, 0, { x: m.x, y: m.y, h: 0, isAction: true, actionId: id });
                }

                addActionMode = false;
                draw(); generateCode();
                return;
            }

            // otherwise add waypoint with default segment type
            saveState();
            // Field-oriented only supports drive segments
            const defaultSegmentType = currentMode === 'field' ? 'drive' : 'drive';
            waypoints.push({ x: m.x, y: m.y, h: 0, segmentType: defaultSegmentType, arcSpeed: 0.8 });
            selectedSegmentIdx = waypoints.length - 1;
            segmentTypeSelect.value = defaultSegmentType;
            arcSpeedInput.value = 0.8;
            draw();
            generateCode();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;
            let hoveringMarker = false;
            for (let i = 0; i < markers.length; i++) {
                const mp = toPixels(markers[i].x, markers[i].y);
                if (Math.hypot(px - mp.x, py - mp.y) < 10) { hoveringMarker = true; break; }
            }
            
            // Check if hovering over waypoint for easier clicking
            let hoveringWaypoint = false;
            for (let i = 0; i < waypoints.length; i++) {
                const pos = toPixels(waypoints[i].x, waypoints[i].y);
                if (Math.hypot(px - pos.x, py - pos.y) < 15) { hoveringWaypoint = true; break; }
            }
            
            if (hoveringMarker) canvas.style.cursor = addActionMode ? 'copy' : 'pointer';
            else if (hoveringWaypoint) canvas.style.cursor = 'move';
            else canvas.style.cursor = 'crosshair';

            if (draggingIdx === -1 && draggingHIdx === -1 && draggingArcControlIdx === -1) return;
            const m = toMeters(px, py);
            if (draggingIdx >= 0) {
                waypoints[draggingIdx].x = m.x;
                waypoints[draggingIdx].y = m.y;
                draw(); generateCode();
            } else if (draggingIdx === -2) {
                start.x = m.x; start.y = m.y; draw(); generateCode();
            } else if (draggingHIdx >= 0) {
                const pos = toPixels(waypoints[draggingHIdx].x, waypoints[draggingHIdx].y);
                waypoints[draggingHIdx].h = Math.atan2(py - pos.y, px - pos.x);
                draw(); generateCode();
            } else if (draggingHIdx === -2) {
                const pos = toPixels(start.x, start.y);
                start.h = Math.atan2(py - pos.y, px - pos.x);
                draw(); generateCode();
            } else if (draggingArcControlIdx >= 0) {
                waypoints[draggingArcControlIdx].arcControlPoint = m;
                draw(); generateCode();
            }
        });

        window.addEventListener('mouseup', () => { draggingIdx = -1; draggingHIdx = -1; draggingArcControlIdx = -1; });

        segmentTypeSelect.addEventListener('change', () => {
            if (selectedSegmentIdx !== null && waypoints[selectedSegmentIdx]) {
                saveState();
                // Prevent arc in field-oriented mode
                if (currentMode === 'field' && segmentTypeSelect.value === 'arc') {
                    segmentTypeSelect.value = 'drive';
                    return;
                }
                waypoints[selectedSegmentIdx].segmentType = segmentTypeSelect.value;
                draw(); generateCode();
            }
        });

        arcSpeedInput.addEventListener('change', () => {
            if (selectedSegmentIdx !== null && waypoints[selectedSegmentIdx]) {
                saveState();
                waypoints[selectedSegmentIdx].arcSpeed = parseFloat(arcSpeedInput.value);
                generateCode();
            }
        });

        function handlePosPixels(p) {
            const pos = toPixels(p.x, p.y);
            const r = 18;
            return { x: pos.x + Math.cos(p.h) * r, y: pos.y + Math.sin(p.h) * r };
        }

        function startHandlePosPixels() {
            const pos = toPixels(start.x, start.y);
            const r = 18;
            return { x: pos.x + Math.cos(start.h) * r, y: pos.y + Math.sin(start.h) * r };
        }

        function deleteSelectedPoint() {
            if (selectedSegmentIdx !== null && selectedSegmentIdx >= 0 && waypoints[selectedSegmentIdx]) {
                saveState();
                waypoints.splice(selectedSegmentIdx, 1);
                selectedSegmentIdx = null;
                draw(); generateCode();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (fieldImg.complete && drawW > 0 && drawH > 0) {
                ctx.drawImage(fieldImg, drawX, drawY, drawW, drawH);
            }

            const spos = toPixels(start.x, start.y);
            ctx.fillStyle = "#10b981";
            ctx.beginPath(); ctx.arc(spos.x, spos.y, 8, 0, Math.PI * 2); ctx.fill();
            const sh = startHandlePosPixels();
            ctx.strokeStyle = '#10b981'; ctx.beginPath(); ctx.moveTo(spos.x, spos.y); ctx.lineTo(sh.x, sh.y); ctx.stroke();
            ctx.fillStyle = '#065f46'; ctx.beginPath(); ctx.arc(sh.x, sh.y, 6, 0, Math.PI*2); ctx.fill();

            if (waypoints.length > 0) {
                const first = toPixels(waypoints[0].x, waypoints[0].y);
                ctx.strokeStyle = "#6366f1";
                ctx.beginPath(); ctx.moveTo(spos.x, spos.y); ctx.lineTo(first.x, first.y); ctx.stroke();
            }

            waypoints.forEach((p, i) => {
                const pos = toPixels(p.x, p.y);

                // Highlight selected waypoint
                if (i === selectedSegmentIdx) {
                    ctx.fillStyle = 'rgba(16, 185, 129, 0.3)';
                    ctx.beginPath(); ctx.arc(pos.x, pos.y, 12, 0, Math.PI * 2); ctx.fill();
                }

                if (p.isAction) {
                    ctx.fillStyle = '#a78bfa';
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y - 7);
                    ctx.lineTo(pos.x + 7, pos.y);
                    ctx.lineTo(pos.x, pos.y + 7);
                    ctx.lineTo(pos.x - 7, pos.y);
                    ctx.closePath(); ctx.fill();
                    const m = markers.find(x => x.id === p.actionId);
                    if (m) {
                        ctx.fillStyle = '#fff'; ctx.font = '10px sans-serif'; ctx.fillText(m.name, pos.x + 10, pos.y + 3);
                    }
                } else {
                    const color = p.segmentType === 'strafe' ? '#eab308' : (p.segmentType === 'arc' ? '#06b6d4' : '#3b82f6');
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2); ctx.fill();
                }

                const prev = (i === 0) ? toPixels(start.x, start.y) : toPixels(waypoints[i-1].x, waypoints[i-1].y);
                const color = p.segmentType === 'strafe' ? '#eab308' : (p.segmentType === 'arc' ? '#06b6d4' : '#3b82f6');
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;

                // In field-oriented mode, always show linear paths
                if (currentMode === 'field' || p.segmentType === 'drive' || p.segmentType === 'strafe') {
                    ctx.beginPath(); ctx.moveTo(prev.x, prev.y); ctx.lineTo(pos.x, pos.y); ctx.stroke();
                } else if (p.segmentType === 'arc') {
                    const prevWp = (i === 0) ? start : waypoints[i-1];
                    const startHeading = (i === 0) ? start.h : waypoints[i-1].h;
                    const endHeading = p.h;
                    const headingDelta = wrapDeg(radToDeg(endHeading - startHeading));
                    
                    const dx = p.x - prevWp.x;
                    const dy = p.y - prevWp.y;
                    const dist = Math.hypot(dx, dy);
                    const segAngle = Math.atan2(dy, dx);

                    if (dist > 0.05) {
                        const startX = prev.x, startY = prev.y;
                        const endX = pos.x, endY = pos.y;
                        
                        let controlX, controlY;
                        
                        if (p.arcControlPoint) {
                            const cp = toPixels(p.arcControlPoint.x, p.arcControlPoint.y);
                            controlX = cp.x;
                            controlY = cp.y;
                        } else {
                            const perpAngle = segAngle + (Math.sign(headingDelta) || 1) * Math.PI / 2;
                            const arcRadius = dist / (2 * Math.sin(Math.abs(degToRad(headingDelta / 2)) || 0.1));
                            const controlDist = Math.min(Math.abs(arcRadius) * 0.3, dist * 0.5);
                            
                            const midX = (startX + endX) / 2;
                            const midY = (startY + endY) / 2;
                            controlX = midX + Math.cos(perpAngle) * controlDist;
                            controlY = midY + Math.sin(perpAngle) * controlDist;
                            
                            if (!p.arcControlPoint) {
                                p.arcControlPoint = toMeters(controlX, controlY);
                            }
                        }

                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                        ctx.stroke();
                    }
                }
                ctx.lineWidth = 1;

                if (!p.isAction && currentMode === 'robot') {
                    const hp = handlePosPixels(p);
                    ctx.strokeStyle = '#f59e0b'; ctx.beginPath(); ctx.moveTo(pos.x, pos.y); ctx.lineTo(hp.x, hp.y); ctx.stroke();
                    ctx.fillStyle = '#b45309'; ctx.beginPath(); ctx.arc(hp.x, hp.y, 6, 0, Math.PI*2); ctx.fill();
                    
                    if (p.segmentType === 'arc' && p.arcControlPoint) {
                        const acp = toPixels(p.arcControlPoint.x, p.arcControlPoint.y);
                        ctx.strokeStyle = '#ec4899'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(pos.x, pos.y); ctx.lineTo(acp.x, acp.y); ctx.stroke();
                        ctx.fillStyle = '#be185d'; ctx.beginPath(); ctx.arc(acp.x, acp.y, 8, 0, Math.PI*2); ctx.fill();
                        ctx.fillStyle = '#fce7f3'; ctx.font = 'bold 10px sans-serif'; ctx.fillText('C', acp.x - 3, acp.y + 3);
                    }
                }
            });

            markers.forEach((a) => {
                const p = toPixels(a.x, a.y);
                ctx.strokeStyle = '#7c3aed'; ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y - 7);
                ctx.lineTo(p.x + 7, p.y);
                ctx.lineTo(p.x, p.y + 7);
                ctx.lineTo(p.x - 7, p.y);
                ctx.closePath(); ctx.stroke();
                ctx.fillStyle = 'rgba(167,139,250,0.35)'; ctx.fill();
            });

            if (btnAddAction) {
                if (addActionMode) {
                    btnAddAction.style.background = '#10b981';
                    btnAddAction.style.color = '#001f13';
                    btnAddAction.textContent = 'Add Action: Click field';
                } else {
                    btnAddAction.style.background = '';
                    btnAddAction.style.color = '';
                    btnAddAction.textContent = 'Add Action';
                }
            }
        }

        function generateCode() {
            if (currentMode === 'field') {
                generateFieldOrientedCode();
            } else {
                generateRobotOrientedCode();
            }
        }

        function generateRobotOrientedCode() {
            function radToDeg(r) { return r * 180 / Math.PI; }
            function wrapDeg(d) { while (d > 180) d -= 360; while (d < -180) d += 360; return d; }

            let code = "// Generated Path (robot-oriented)\n";
            code += `// Start: x=${start.x.toFixed(2)} y=${start.y.toFixed(2)} h=${radToDeg(-start.h).toFixed(1)}deg\n\n`;

            const pts = [start].concat(waypoints);
            const startHeadingDeg = radToDeg(-pts[0].h);
            code += `turnPID(${startHeadingDeg.toFixed(1)}); // face start heading\n`;

            let curHeading = startHeadingDeg;

            for (let i = 1; i < pts.length; i++) {
                const prev = pts[i-1];
                const cur = pts[i];
                const dx = cur.x - prev.x;
                const dy = cur.y - prev.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (dist < 0.001) {
                    if (Math.abs(cur.h) > 0.0001) {
                        const wh = radToDeg(-cur.h);
                        code += `turnPID(${wh.toFixed(1)}); // snap to waypoint heading\n`;
                    }
                    continue;
                }

                const segAngleRad = Math.atan2(dy, dx);
                const segAngleDeg = radToDeg(segAngleRad);

                const segmentType = cur.segmentType || 'drive';
                const arcSpeed = cur.arcSpeed || 0.8;

                if (segmentType === 'arc') {
                    const startH = radToDeg(-prev.h);
                    const endH = radToDeg(-cur.h);
                    code += `arc(${dist.toFixed(2)}, ${arcSpeed.toFixed(2)}, t -> t.at(1.0, ${Math.round(endH)}));\n`;
                    curHeading = endH;
                } else if (segmentType === 'strafe') {
                    code += `strafePID(${dist.toFixed(2)}, ${Math.round(segAngleDeg)});\n`;
                    curHeading = segAngleDeg;
                } else {
                    code += `turnPID(${segAngleDeg.toFixed(1)});\n`;
                    code += `drivePID(${dist.toFixed(2)}, ${segAngleDeg.toFixed(1)});\n`;
                    curHeading = segAngleDeg;
                }

                if (Math.abs(cur.h) > 0.0001 && segmentType !== 'arc') {
                    const wh = radToDeg(-cur.h);
                    const delta = wrapDeg(wh - segAngleDeg);
                    if (Math.abs(delta) > 1.0) {
                        code += `turnPID(${wh.toFixed(1)}); // waypoint heading\n`;
                    }
                }

                if (cur.isAction && cur.actionId) {
                    const a = markers.find(m => m.id === cur.actionId);
                    if (a) {
                        code += `// action: ${a.name} at x=${cur.x.toFixed(2)} y=${cur.y.toFixed(2)}\n`;
                        if (a.args && a.args.length > 0) code += `${a.name}(${a.args});\n`; else code += `${a.name}();\n`;
                        code += `// TODO: implement ${a.name} in your AutoEngine (placeholder)\n`;
                    }
                }
            }

            output.value = code;
        }

        function generateFieldOrientedCode() {
            function radToDeg(r) { return r * 180 / Math.PI; }

            let code = "";
            
            // Generate createPath() method
            code += "/**\n";
            code += " * Define your path as a series of waypoints in Centimeters.\n";
            code += " */\n";
            code += "private List<Pose2d> createPath() {\n";
            code += "    List<Pose2d> waypoints = new ArrayList<>();\n\n";

            // Add start pose
            const startCmX = (start.x * 100).toFixed(1);
            const startCmY = (start.y * 100).toFixed(1);
            const startDeg = radToDeg(-start.h).toFixed(1);
            code += `    // Start pose\n`;
            code += `    waypoints.add(new Pose2d(${startCmX}, ${startCmY}, Rotation2d.fromDegrees(${startDeg})));\n\n`;

            // Add waypoints (only non-action waypoints)
            waypoints.forEach((wp, i) => {
                if (!wp.isAction) {
                    const cmX = (wp.x * 100).toFixed(1);
                    const cmY = (wp.y * 100).toFixed(1);
                    const deg = radToDeg(-wp.h).toFixed(1);
                    code += `    waypoints.add(new Pose2d(${cmX}, ${cmY}, Rotation2d.fromDegrees(${deg})));\n`;
                }
            });

            code += "\n    return waypoints;\n";
            code += "}\n\n";

            // Generate createMarkers() method if there are actions
            const hasActions = waypoints.some(wp => wp.isAction);
            if (hasActions) {
                code += "/**\n";
                code += " * Define markers to trigger actions at specific points in the path.\n";
                code += " * Uses the PathMarker class and RobotAction interface from the Follower parent.\n";
                code += " */\n";
                code += "private List<PathMarker> createMarkers() {\n";
                code += "    List<PathMarker> markers = new ArrayList<>();\n\n";

                // Add markers for actions
                let pathPercentage = 0;
                let totalWaypoints = waypoints.filter(wp => !wp.isAction).length;
                let currentWaypointIndex = 0;
                
                waypoints.forEach((wp, i) => {
                    if (!wp.isAction) {
                        currentWaypointIndex++;
                    } else {
                        const marker = markers.find(m => m.id === wp.actionId);
                        if (marker) {
                            const percent = ((currentWaypointIndex / totalWaypoints) * 100).toFixed(1);
                            code += `    markers.add(new PathMarker(${percent}, () -> {\n`;
                            code += `        // ${marker.name}\n`;
                            if (marker.args) code += `        // Args: ${marker.args}\n`;
                            code += `        telemetry.addData("Marker", "${percent}% - ${marker.name}");\n`;
                            code += `        telemetry.update();\n`;
                            code += `    }));\n\n`;
                        }
                    }
                });

                code += "    return markers;\n";
                code += "}\n";
            } else {
                code += "/**\n";
                code += " * No markers defined. Return empty list or implement as needed.\n";
                code += " */\n";
                code += "private List<PathMarker> createMarkers() {\n";
                code += "    return new ArrayList<>();\n";
                code += "}\n";
            }

            output.value = code;
        }

        function clearPath() {
            if (confirm('Clear all waypoints?')) {
                saveState();
                waypoints = [];
                markers = [];
                start = { x: 0, y: 0, h: 0 };
                selectedSegmentIdx = null;
                draw();
                output.value = "";
            }
        }

        function toggleAddAction() { addActionMode = !addActionMode; draw(); }
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && addActionMode) {
                addActionMode = false; draw();
            }
            if (e.key === 'Delete' && selectedSegmentIdx !== null) {
                deleteSelectedPoint();
            }
        });
        function copyCode() { output.select(); document.execCommand('copy'); alert('Code copied!'); }
        function toggleSetStart() { setStartMode = !setStartMode; }

        function simulate() {
            if (isSimulating) return;
            const points = [start].concat(waypoints);
            if (points.length < 2) return;
            isSimulating = true;

            const driveSpeed = 0.8;
            const turnSpeedDeg = 120;

            let seg = 0;
            let phase = 'turn';
            let pos = { x: points[0].x, y: points[0].y };
            let heading = radToDeg(-points[0].h);
            let totalDistance = 0;
            let distanceTraveled = 0;

            function segInfo(i) {
                const a = points[i];
                const b = points[i+1];
                const dx = b.x - a.x; const dy = b.y - a.y;
                const len = Math.hypot(dx, dy);
                const ang = radToDeg(Math.atan2(dy, dx));
                const segmentType = b.segmentType || 'drive';
                return { len, ang, a, b, segmentType };
            }

            function bezierPoint(t, p0x, p0y, p1x, p1y, p2x, p2y) {
                const mt = 1 - t;
                const x = mt * mt * p0x + 2 * mt * t * p1x + t * t * p2x;
                const y = mt * mt * p0y + 2 * mt * t * p1y + t * t * p2y;
                return { x, y };
            }

            function getArcControlPoint(segIdx) {
                if (segIdx < 1 || segIdx >= waypoints.length) return null;
                const wp = waypoints[segIdx];
                if (wp.segmentType === 'arc' && wp.arcControlPoint) {
                    return wp.arcControlPoint;
                }
                return null;
            }

            // Calculate total distance
            for (let i = 0; i < points.length - 1; i++) {
                totalDistance += segInfo(i).len;
            }

            // Pre-calculate path points for visualization
            const pathPoints = [];
            for (let i = 0; i < points.length - 1; i++) {
                const info = segInfo(i);
                
                if (info.segmentType === 'arc' && currentMode === 'robot') {
                    let controlPt = getArcControlPoint(i);
                    if (!controlPt) {
                        const dx = info.b.x - info.a.x;
                        const dy = info.b.y - info.a.y;
                        const dist = Math.hypot(dx, dy);
                        const segAngle = Math.atan2(dy, dx);
                        const startH = (i === 0) ? start.h : waypoints[i-1].h;
                        const endH = info.b.h;
                        const headingDelta = wrapDeg(radToDeg(endH - startH));
                        const perpAngle = segAngle + (Math.sign(headingDelta) || 1) * Math.PI / 2;
                        const arcRadius = dist / (2 * Math.sin(Math.abs(degToRad(headingDelta / 2)) || 0.1));
                        const controlDist = Math.min(Math.abs(arcRadius) * 0.3, dist * 0.5);
                        const midX = (info.a.x + info.b.x) / 2;
                        const midY = (info.a.y + info.b.y) / 2;
                        controlPt = {
                            x: midX + Math.cos(perpAngle) * controlDist,
                            y: midY + Math.sin(perpAngle) * controlDist
                        };
                    }
                    
                    // Sample arc curve
                    for (let t = 0; t <= 1; t += 0.05) {
                        const pt = bezierPoint(t, info.a.x, info.a.y, controlPt.x, controlPt.y, info.b.x, info.b.y);
                        pathPoints.push(pt);
                    }
                } else {
                    pathPoints.push(info.a);
                    pathPoints.push(info.b);
                }
            }

            let driveProgress = 0;

            function step(dt) {
                if (!isSimulating) return;
                const info = (seg < points.length-1) ? segInfo(seg) : null;

                if (!info) { isSimulating = false; draw(); return; }

                const segType = info.segmentType;

                if (phase === 'turn') {
                    const target = wrapDeg(info.ang);
                    const diff = wrapDeg(target - heading);
                    const maxStep = turnSpeedDeg * (dt/1000) * simSpeed;
                    if (Math.abs(diff) <= 0.5) {
                        heading = target;
                        if (segType === 'strafe') {
                            const roundedHeading = Math.round(heading / 90) * 90;
                            heading = wrapDeg(roundedHeading);
                            phase = 'strafe';
                        } else if (segType === 'arc') {
                            phase = 'arc';
                        } else {
                            phase = 'drive';
                        }
                        driveProgress = 0;
                    } else {
                        heading += Math.sign(diff) * Math.min(maxStep, Math.abs(diff));
                    }
                } else if (phase === 'drive') {
                    const travel = driveSpeed * (dt/1000) * simSpeed;
                    driveProgress += travel;
                    distanceTraveled += travel;
                    const frac = Math.min(1, driveProgress / info.len || 1);
                    pos.x = info.a.x + (info.b.x - info.a.x) * frac;
                    pos.y = info.a.y + (info.b.y - info.a.y) * frac;
                    heading = info.ang;

                    if (frac >= 1) {
                        const wpHeading = radToDeg(-points[seg+1].h);
                        if (Math.abs(wpHeading) > 0.0001) {
                            phase = 'wpTurn';
                        } else {
                            seg++;
                            phase = 'turn';
                        }
                    }
                } else if (phase === 'strafe') {
                    const travel = driveSpeed * (dt/1000) * simSpeed;
                    driveProgress += travel;
                    distanceTraveled += travel;
                    const frac = Math.min(1, driveProgress / info.len || 1);
                    
                    pos.x = info.a.x + (info.b.x - info.a.x) * frac;
                    pos.y = info.a.y + (info.b.y - info.a.y) * frac;

                    if (frac >= 1) {
                        const wpHeading = radToDeg(-points[seg+1].h);
                        if (Math.abs(wpHeading) > 0.0001) {
                            phase = 'wpTurn';
                        } else {
                            seg++;
                            phase = 'turn';
                        }
                    }
                } else if (phase === 'arc') {
                    const prevWp = (seg === 0) ? start : waypoints[seg-1];
                    const curWp = waypoints[seg];
                    const startHeading = (seg === 0) ? start.h : waypoints[seg-1].h;
                    const endHeading = curWp.h;
                    const headingDelta = wrapDeg(radToDeg(endHeading - startHeading));

                    const travel = driveSpeed * (dt/1000) * simSpeed;
                    driveProgress += travel;
                    distanceTraveled += travel;
                    const frac = Math.min(1, driveProgress / info.len || 1);

                    let controlPt = getArcControlPoint(seg);
                    if (!controlPt) {
                        const dx = info.b.x - info.a.x;
                        const dy = info.b.y - info.a.y;
                        const dist = Math.hypot(dx, dy);
                        const segAngle = Math.atan2(dy, dx);
                        const perpAngle = segAngle + (Math.sign(headingDelta) || 1) * Math.PI / 2;
                        const arcRadius = dist / (2 * Math.sin(Math.abs(degToRad(headingDelta / 2)) || 0.1));
                        const controlDist = Math.min(Math.abs(arcRadius) * 0.3, dist * 0.5);
                        const midX = (info.a.x + info.b.x) / 2;
                        const midY = (info.a.y + info.b.y) / 2;
                        controlPt = {
                            x: midX + Math.cos(perpAngle) * controlDist,
                            y: midY + Math.sin(perpAngle) * controlDist
                        };
                    }

                    const bezPt = bezierPoint(frac, info.a.x, info.a.y, controlPt.x, controlPt.y, info.b.x, info.b.y);
                    pos.x = bezPt.x;
                    pos.y = bezPt.y;

                    const startH = (seg === 0) ? radToDeg(-start.h) : radToDeg(-waypoints[seg-1].h);
                    const endH = radToDeg(-curWp.h);
                    heading = startH + (endH - startH) * frac;
                    heading = wrapDeg(heading);

                    if (frac >= 1) {
                        const wpHeading = radToDeg(-points[seg+1].h);
                        if (Math.abs(wpHeading) > 0.0001) {
                            phase = 'wpTurn';
                        } else {
                            seg++;
                            phase = 'turn';
                        }
                    }
                } else if (phase === 'wpTurn') {
                    const target = wrapDeg(radToDeg(-points[seg+1].h));
                    const diff = wrapDeg(target - heading);
                    const maxStep = turnSpeedDeg * (dt/1000) * simSpeed;
                    if (Math.abs(diff) <= 0.5) {
                        heading = target;
                        seg++;
                        phase = 'turn';
                    } else {
                        heading += Math.sign(diff) * Math.min(maxStep, Math.abs(diff));
                    }
                }

                // Draw everything
                draw();

                // Draw the planned path in green
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.6;
                
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const p1 = toPixels(pathPoints[i].x, pathPoints[i].y);
                    const p2 = toPixels(pathPoints[i + 1].x, pathPoints[i + 1].y);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }

                ctx.globalAlpha = 1.0;
                ctx.lineWidth = 1;

                // Draw robot position
                const ppx = toPixels(pos.x, pos.y);
                ctx.fillStyle = '#ef4444'; 
                ctx.beginPath(); 
                ctx.arc(ppx.x, ppx.y, 8, 0, Math.PI*2); 
                ctx.fill();
                
                // Draw robot heading
                const hRad = degToRad(heading);
                ctx.strokeStyle = '#ffffff'; 
                ctx.lineWidth = 2;
                ctx.beginPath(); 
                ctx.moveTo(ppx.x, ppx.y); 
                ctx.lineTo(ppx.x + Math.cos(hRad) * 18, ppx.y - Math.sin(hRad) * 18); 
                ctx.stroke();
                ctx.lineWidth = 1;

                if (seg >= points.length-1) { isSimulating = false; return; }

                requestAnimationFrame((now) => { step(16); });
            }

            requestAnimationFrame((now) => { step(16); });
        }

        draw();
    </script>
</body>
</html>