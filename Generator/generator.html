<!DOCTYPE html>
<html>
<head>
    <title>Crawlier Path Generator Pro</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; background: #1a1a1b; color: white; margin: 20px; }
        canvas {
            background-color: #2d2d2e;
            background-image: url('fiels.png');
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
            border: 4px solid #3d3d3e;
            cursor: crosshair;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 4px;
        }
        .controls { margin: 20px; padding: 20px; background: #2d2d2e; border-radius: 12px; width: 800px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        textarea { width: 100%; height: 180px; font-family: 'Consolas', monospace; margin-top: 10px; border: 1px solid #444; background: #1a1a1b; color: #10b981; padding: 10px; border-radius: 4px; resize: none; }
        .hint { color: #d1d5db; font-size: 0.95em; margin-bottom: 10px; background: #3730a3; padding: 12px; border-radius: 6px; border-left: 5px solid #6366f1; }
        .toolbar { display: flex; gap: 10px; margin-bottom: 10px; }
        button { padding: 10px 20px; font-weight: bold; cursor: pointer; border: none; border-radius: 6px; transition: 0.2s; }
        .btn-clear { background: #ef4444; color: white; }
        .btn-clear:hover { background: #dc2626; }
        .btn-copy { background: #4f46e5; color: white; }
        .btn-copy:hover { background: #4338ca; }
        .btn-sim { background: #10b981; color: white; }
        .btn-sim:hover { background: #059669; }
    </style>
</head>
<body>
    <h2>Crawlier Path Pro (Metric)</h2>
    <div class="hint">
        <b>Workflow:</b> 1. Click to place point. 2. <b>Drag the Yellow Handle</b> to set Heading. 3. Click "Simulate" to check the arc.
    </div>
    
    <canvas id="field" width="600" height="600"></canvas>

    <div class="controls">
        <div class="toolbar">
            <button class="btn-clear" onclick="clearPath()">Clear Path</button>
            <button class="btn-sim" onclick="simulate()">â–¶ Simulate Path</button>
            <button class="btn-copy" onclick="copyCode()">Copy Java Code</button>
        </div>
        <p><strong>Generated Java Code:</strong></p>
        <textarea id="output" readonly></textarea>
    </div>

    <script>
        const canvas = document.getElementById('field');
        const ctx = canvas.getContext('2d');
        const output = document.getElementById('output');
        const fieldSizeMeters = 3.6576; 
        const ppm = canvas.width / fieldSizeMeters; 

        let waypoints = [];
        let draggingHIdx = -1;
        let simBot = null;

        function toPixels(mx, my) {
            return { x: (mx + fieldSizeMeters / 2) * ppm, y: canvas.height - (my + fieldSizeMeters / 2) * ppm };
        }

        function toMeters(px, py) {
            return { x: (px / ppm) - (fieldSizeMeters / 2), y: ((canvas.height - py) / ppm) - (fieldSizeMeters / 2) };
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;

            // Check if clicking rotation handle (yellow circle)
            let hFound = -1;
            waypoints.forEach((p, i) => {
                const pos = toPixels(parseFloat(p.x), parseFloat(p.y));
                const rad = -p.h * Math.PI / 180;
                const hx = pos.x + Math.cos(rad) * 40;
                const hy = pos.y + Math.sin(rad) * 40;
                if (Math.hypot(hx - px, hy - py) < 15) hFound = i;
            });

            if (hFound !== -1) {
                draggingHIdx = hFound;
            } else {
                const m = toMeters(px, py);
                waypoints.push({ x: m.x.toFixed(3), y: m.y.toFixed(3), h: 0 });
                draw();
                generateCode();
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (draggingHIdx === -1) return;
            const rect = canvas.getBoundingClientRect();
            const px = e.clientX - rect.left;
            const py = e.clientY - rect.top;

            const p = waypoints[draggingHIdx];
            const pos = toPixels(parseFloat(p.x), parseFloat(p.y));
            
            // Calculate angle from center of point to mouse
            let angle = Math.atan2(pos.y - py, px - pos.x) * 180 / Math.PI;
            waypoints[draggingHIdx].h = angle.toFixed(1);
            
            draw();
            generateCode();
        });

        window.addEventListener('mouseup', () => draggingHIdx = -1);

        function drawField() {
            // Draw Tiles (Standard FTC Grey)
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            for(let i=0; i<=6; i++) {
                let pos = (i * 0.6096) * ppm;
                ctx.beginPath(); ctx.moveTo(pos, 0); ctx.lineTo(pos, canvas.height); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, pos); ctx.lineTo(canvas.width, pos); ctx.stroke();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawField();

            if (waypoints.length === 0) return;

            // Draw Paths (Blue Line)
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 3;
            ctx.beginPath();
            waypoints.forEach((p, i) => {
                const pos = toPixels(parseFloat(p.x), parseFloat(p.y));
                if (i === 0) ctx.moveTo(pos.x, pos.y);
                else ctx.lineTo(pos.x, pos.y);
            });
            ctx.stroke();

            // Draw Points
            waypoints.forEach((p, i) => {
                const pos = toPixels(parseFloat(p.x), parseFloat(p.y));
                const rad = -p.h * Math.PI / 180;

                // Rotation Line & Handle
                ctx.strokeStyle = '#fbbf24';
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                const hx = pos.x + Math.cos(rad) * 40;
                const hy = pos.y + Math.sin(rad) * 40;
                ctx.lineTo(hx, hy);
                ctx.stroke();
                
                // Handle Circle
                ctx.fillStyle = '#fbbf24';
                ctx.beginPath(); ctx.arc(hx, hy, 5, 0, Math.PI*2); ctx.fill();

                // Point Dot
                ctx.fillStyle = i === waypoints.length - 1 ? '#ef4444' : '#fff';
                ctx.beginPath(); ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2); ctx.fill();
            });

            if(simBot) {
                ctx.save();
                ctx.translate(simBot.px, simBot.py);
                ctx.rotate(-simBot.h * Math.PI / 180);
                ctx.fillStyle = "rgba(16, 185, 129, 0.5)";
                ctx.fillRect(-15, -15, 30, 30); // Robot Body
                ctx.strokeStyle = "white";
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(20, 0); ctx.stroke(); // Front indicator
                ctx.restore();
            }
        }

        function simulate() {
            if (waypoints.length < 2) return;
            let step = 0;
            simBot = { 
                px: toPixels(parseFloat(waypoints[0].x), parseFloat(waypoints[0].y)).x, 
                py: toPixels(parseFloat(waypoints[0].x), parseFloat(waypoints[0].y)).y, 
                h: parseFloat(waypoints[0].h) 
            };
            
            const animate = () => {
                if (step >= waypoints.length) { simBot = null; draw(); return; }
                const p = waypoints[step];
                const target = toPixels(parseFloat(p.x), parseFloat(p.y));
                const targetH = parseFloat(p.h);
                
                const dx = target.x - simBot.px;
                const dy = target.y - simBot.py;
                const dist = Math.hypot(dx, dy);
                
                if (dist > 2) {
                    simBot.px += (dx / dist) * 3;
                    simBot.py += (dy / dist) * 3;
                } else {
                    step++;
                }
                
                // Smooth heading rotation
                let headingDiff = targetH - simBot.h;
                if (headingDiff > 180) headingDiff -= 360;
                if (headingDiff < -180) headingDiff += 360;
                simBot.h += headingDiff * 0.1;
                
                draw();
                requestAnimationFrame(animate);
            };
            animate();
        }

        function generateCode() {
            let code = "List<Task> generatedPath = builder\n";
            waypoints.forEach((p, i) => {
                const xIn = (p.x * 39.37).toFixed(2);
                const yIn = (p.y * 39.37).toFixed(2);
                if (i === waypoints.length - 1) code += `    .driveTo(${xIn}, ${yIn}, ${p.h})\n`;
                else code += `    .waypoint(${xIn}, ${yIn}, ${p.h}, 4.0)\n`;
            });
            output.value = code + "    .build();";
        }

        function clearPath() { waypoints = []; draw(); output.value = ""; }
        function copyCode() { output.select(); document.execCommand('copy'); }
        draw();
    </script>
</body>
</html>